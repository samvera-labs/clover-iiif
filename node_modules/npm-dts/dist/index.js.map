{"version":3,"sources":["webpack://npm-dts/webpack/universalModuleDefinition","webpack://npm-dts/./lib/cli.ts","webpack://npm-dts/./lib/generator.ts","webpack://npm-dts/./lib/log.ts","webpack://npm-dts/external \"args\"","webpack://npm-dts/external \"fs\"","webpack://npm-dts/external \"mkdirp\"","webpack://npm-dts/external \"npm-run\"","webpack://npm-dts/external \"path\"","webpack://npm-dts/external \"rimraf\"","webpack://npm-dts/external \"tmp\"","webpack://npm-dts/external \"winston\"","webpack://npm-dts/webpack/bootstrap","webpack://npm-dts/./index.ts"],"names":["root","factory","exports","module","define","amd","a","i","global","ECliArgument","injectedArguments","launched","tmpPassed","args","entry","path","resolve","process","cwd","tmp","tsc","logLevel","ELogLevel","info","force","output","testMode","this","storeArguments","option","value","includes","command","name","sub","options","example","parse","argv","mri","mainColor","subColor","showHelp","getArgument","arg","setArgument","passedArguments","Object","keys","argName","is","undefined","Cli","IBasePathType","enableLog","throwErrors","cacheContentEmptied","init","getLogLevel","soft","JSON","readFileSync","__dirname","encoding","version","author","spaces","border","substring","length","generate","getRoot","hasError","exception","cleanupTasks","verbose","Promise","done","dir","tmpErr","tmpDir","rmTmp","error","showDebugError","push","_generate","catch","e","getOutput","useForce","debug","clearTempDir","forEach","task","Error","stdout","toString","stringify","generateTypings","combineTypings","source","addAlias","storeResult","getEntry","getTempDir","useTestMode","makeTempDir","retries","fail","mkdir","then","mkdirError","setTimeout","rm","rmError","resetCacheDir","tscOptions","cmd","npmRun","execSync","err","stderr","warn","write","getDeclarationFiles","files","readdirSync","file","statSync","join","isDirectory","concat","getPackageDetails","packageInfo","packageJsonPath","convertPathToModule","rootType","noPrefix","noExtensionRemoval","noExistenceCheck","packageDetails","fileExisted","fs","existsSync","lstatSync","isFile","relative","replace","loadTypings","result","declarationFiles","moduleName","resolveImportSourcesAtLine","regexp","line","matches","match","startsWith","relativePath","resolvedModule","moduleExists","resolveImportSources","lines","split","map","typings","moduleNames","sourceParts","entries","fileSource","mainFile","folderPath","dirname","writeFileSync","Generator","winston","addColors","logEnabled","message","label","level","configure","format","combine","colorize","timestamp","prettyPrint","printf","parts","transports","Console","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"mappings":"CAAA,SAA2CA,EAAMC,GAChD,GAAsB,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,SACb,GAAqB,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,OACP,CACJ,IAAIK,EAAIL,IACR,IAAI,IAAIM,KAAKD,GAAuB,iBAAZJ,QAAuBA,QAAUF,GAAMO,GAAKD,EAAEC,IAPxE,CASGC,QAAQ,WACX,M,uGCVA,IAOYC,EAPZ,SACA,SACA,UAKYA,EAAA,EAAAA,eAAA,EAAAA,aAAY,KAItB,cAKA,cAKA,YAKA,YAKA,sBAKA,kBAOA,sBAKA,gBA0DF,iBA4BE,WAAmBC,GAAnB,WAxBU,KAAAC,UAAW,EAKX,KAAAC,WAAY,EAKd,KAAAC,KAAoB,CAC1BC,MAAO,WACPd,KAAMe,EAAKC,QAAQC,QAAQC,OAC3BC,IAAK,SACLC,IAAK,GACLC,SAAU,EAAAC,UAAUC,KACpBC,OAAO,EACPC,OAAQ,aACRC,UAAU,GAONhB,GACFiB,KAAKhB,UAAW,EAChBgB,KAAKC,eAAelB,KAEpBG,EACGgB,OACC,CAAC,IAAK,SACN,qEAEDA,OACC,CAAC,IAAK,QACN,gDACAF,KAAKd,KAAKb,MAEX6B,OACC,CAAC,IAAK,OACN,8CACAF,KAAKd,KAAKM,KACV,SAACW,GAKC,OAJKA,EAAMC,SAAS,OAClB,EAAKnB,WAAY,GAGZkB,KAGVD,OACC,CAAC,IAAK,OACN,sDACAF,KAAKd,KAAKO,KAEXS,OACC,CAAC,IAAK,YACN,gDACAF,KAAKd,KAAKQ,UAEXQ,OACC,CAAC,IAAK,SACN,kFACAF,KAAKd,KAAKW,OAEXK,OACC,CAAC,IAAK,UACN,sDACAF,KAAKd,KAAKY,QAEXI,OACC,CAAC,IAAK,YACN,mCACAF,KAAKd,KAAKa,UAEXM,QAAQ,WAAY,oBAAoB,SAACC,EAAMC,EAAKC,GACnD,EAAKxB,UAAW,EAChB,EAAKiB,eAAeO,MAErBC,QACC,mBACA,+DAEDA,QACC,yCACA,yCAGJvB,EAAKwB,MAAMpB,QAAQqB,KAAM,CACvBL,KAAM,UACNM,IAAK,GACLC,UAAW,SACXC,SAAU,QAGPd,KAAKhB,UACRE,EAAK6B,YAkCb,OAzBY,YAAAC,YAAV,SAAsBC,GACpB,OAAOjB,KAAKd,KAAK+B,IAQT,YAAAC,YAAV,SAAsBD,EAAmBd,GAEvCH,KAAKd,KAAK+B,GAAOd,GAOX,YAAAF,eAAR,SAAuBkB,QAAA,IAAAA,MAAuBnB,KAAKd,MACjD,IAAsB,UAAAkC,OAAOC,KAAKrB,KAAKd,MAAjB,eAAwB,CAAzC,IAAMoC,EAAO,KAChBtB,KAAKd,KAAKoC,GAAWF,OAAOG,GAAGJ,EAAgBG,QAAUE,GACrDxB,KAAKd,KAAKoC,GACVH,EAAgBG,KAG1B,EAvIA,GAAa,EAAAG,O,i8DC1Gb,IAipBYC,EAjpBZ,SACA,SACA,SACA,SACA,SACA,SACA,SACA,QACA,SACA,SAOA,cAYE,WACE3C,EACA4C,EACAC,QADA,IAAAD,MAAA,WACA,IAAAC,OAAA,GAHF,MAKE,YAAM7C,IAAkB,KAQxB,GArBM,EAAA8C,qBAA+B,EAerC,EAAKD,YAAcA,EAED,OAAdD,IACFA,GAAa5C,GAGX4C,EAAW,CACb,EAAAG,KAAK,UAAW,EAAKC,eAErB,IAMMC,EAAO,sBANSC,KAAKvB,MACzB,EAAAwB,aAAa,EAAA7C,QAAQ8C,UAAW,KAAM,gBAAiB,CACrDC,SAAU,UAImCC,QAAO,mBACpDC,EAAS,8DACTC,EAAS,8DACTC,EAAS,8DAEbF,EAASA,EAAOG,UAAU,EAAGT,EAAKU,QAClCH,EAASA,EAAOE,UAAU,EAAGT,EAAKU,QAClCF,EAASA,EAAOC,UAAU,EAAGT,EAAKU,QAElC,EAAA9C,KAAK,IAAI4C,EAAM,KACf,EAAA5C,KAAK,IAAI2C,EAAM,KACf,EAAA3C,KAAK,IAAI2C,EAAM,KACf,EAAA3C,KAAK,IAAIoC,EAAI,KACb,EAAApC,KAAK,IAAI0C,EAAM,KACf,EAAA1C,KAAK,IAAI2C,EAAM,KACf,EAAA3C,KAAK,IAAI4C,EAAM,KACf,EAAA5C,KAAK,IAAI2C,EAAM,K,SAmkBrB,OArnB+B,OAyDhB,YAAAI,SAAb,W,gHACE,EAAA/C,KAAK,gCAAgCI,KAAK4C,UAAS,QAE/CC,GAAW,EACXC,EAAY,KACVC,EAA+B,GAEhC/C,KAAKf,UAAN,YACF,EAAA+D,QAAQ,sC,iBAGN,O,sBAAA,GAAM,IAAIC,SAAc,SAAAC,GACtB1D,EAAI2D,KAAI,SAACC,EAAQC,EAAQC,GACvB,GAAIF,EAGF,MAFA,EAAAG,MAAM,4CACN,EAAKC,eAAeJ,GACdA,EAGR,EAAAJ,QAAQ,uCACR,EAAK9B,YAAY,EAAApC,aAAaU,IAAK,EAAAH,QAAQgE,EAAQ,YAEnDN,EAAaU,MAAK,WAChB,EAAAT,QAAQ,sCACRM,IACA,EAAAN,QAAQ,0CAEVE,W,cAhBJ,S,+BAoBAL,GAAW,EACXC,EAAY,E,oBAIXD,EAAD,MACF,GAAM7C,KAAK0D,YAAYC,OAAM,SAAMC,GAAC,qC,+DAClCf,GAAW,EAEL/C,EAASE,KAAK6D,YAEpB,EAAAN,MAAM,iBAAiBzD,EAAM,gBAC7BE,KAAKwD,eAAeI,GAEf5D,KAAK8D,aACJ9D,KAAK+B,gBAAkB,EAAApC,UAAUoE,OACnC,EAAAnE,KACE,2EAEF,EAAAA,KACE,qEAGF,EAAAA,KAAK,4DACL,EAAAA,KACE,sEAKDI,KAAK6B,oBAAN,MACF,GAAM7B,KAAKgE,gB,OAAX,S,wBAGFlB,EAAYc,E,sBA5Bd,S,iBAkCF,GAFAb,EAAakB,SAAQ,SAAAC,GAAQ,OAAAA,OAExBrB,GAKH,GAFA,EAAAU,MAAM,sBAEFvD,KAAK4B,YACP,MAAMkB,GAAa,IAAIqB,MAAM,2BAL/B,EAAAvE,KAAK,4B,kBAcD,YAAA4D,eAAR,SAAuBI,GACjBA,IACEA,EAAEQ,OACJ,EAAAL,MAAM,YAAYH,EAAEQ,OAAOC,YAE3B,EAAAN,MAAM,YAAY9B,KAAKqC,UAAUV,MAQzB,YAAAF,UAAd,W,gGACE,SAAM1D,KAAKuE,mB,OACE,OADb,SACa,GAAMvE,KAAKwE,kB,OAExB,OAFIC,EAAS,SACbA,EAASzE,KAAK0E,SAASD,GACvB,GAAMzE,KAAK2E,YAAYF,I,cAAvB,S,YAGM,YAAA1C,YAAR,WACE,IAAMrC,EAAWM,KAAKgB,YAAY,EAAAlC,aAAaY,UAC/C,OAAO,EAAAC,UAAUD,GAAYA,EAAW,EAAAC,UAAUC,MAM5C,YAAAgF,SAAR,WACE,OAAO5E,KAAKgB,YAAY,EAAAlC,aAAaK,QAM/B,YAAAyD,QAAR,WACE,OAAO,EAAAvD,QAAQW,KAAKgB,YAAY,EAAAlC,aAAaT,QAMvC,YAAAwG,WAAR,WACE,OAAO,EAAAxF,QAAQW,KAAKgB,YAAY,EAAAlC,aAAaU,OAMvC,YAAAqE,UAAR,WACE,OAAO7D,KAAKgB,YAAY,EAAAlC,aAAagB,SAM/B,YAAAgF,YAAR,WACE,OAAO9E,KAAKgB,YAAY,EAAAlC,aAAaiB,WAM/B,YAAA+D,SAAR,WACE,OAAO9D,KAAKgB,YAAY,EAAAlC,aAAae,QAO/B,YAAAkF,YAAR,SAAoBC,GAApB,gBAAoB,IAAAA,MA3NA,GA4NlB,IAAM3B,EAASrD,KAAK6E,aAGpB,OAFA,EAAA7B,QAAQ,gCAED,IAAIC,SAAQ,SAACC,EAAM+B,GACxBC,EAAM7B,GACH8B,MAAK,WACJ,EAAKtD,qBAAsB,EAC3B,EAAAmB,QAAQ,iCACRE,OAEDS,OAAM,SAAAyB,GACL,EAAA7B,MAAM,qBAAqBF,EAAM,MACjC,EAAKG,eAAe4B,GAEhBJ,GAEF,EAAAhC,QAAQ,0BAERqC,YAAW,WACT,EAAKN,YAAYC,EAAU,GAAGG,KAAKjC,EAAM+B,KAJzB,OAOlB,EAAA1B,MAAM,mCACN0B,YASF,YAAAjB,aAAR,sBACQX,EAASrD,KAAK6E,aAGpB,OAFA,EAAA7B,QAAQ,kCAED,IAAIC,SAAc,SAACC,EAAM+B,GAC9BK,EAAGjC,GAAQ,SAAAkC,GACLA,GACF,EAAAhC,MAAM,0CAA0CF,EAAM,MACtD,EAAKG,eAAe+B,GACpBN,MAEA,EAAKpD,qBAAsB,EAC3B,EAAAmB,QAAQ,gCACRE,YASA,YAAAsC,cAAR,sBAEE,OADA,EAAAxC,QAAQ,qCACD,IAAIC,SAAQ,SAACC,EAAM+B,GACxB,EAAKjB,eAAemB,MAAK,WACvB,EAAKJ,cAAcI,KAAKjC,EAAM+B,KAC7BA,OAOO,YAAAV,gBAAd,W,yGACE,SAAMvE,KAAKwF,iB,OAAX,SAEA,EAAAxC,QAAQ,4CAEFyC,EAAazF,KAAKgB,YAAY,EAAAlC,aAAaW,KAE3CiG,EACJ,6DACA1F,KAAK6E,aACL,KACCY,EAAW/C,OAAS,IAAI+C,EAAe,IAE1C,EAAA1B,MAAM2B,GAEN,IACEC,EAAOC,SACLF,EACA,CACEnG,IAAKS,KAAK8E,cAAgB,EAAAzF,QAAQ8C,UAAW,MAAQnC,KAAK4C,YAE5D,SAACiD,EAAUzB,EAAa0B,GAClBD,GACE,EAAK/B,WACP,EAAAiC,KAAK,2BAEL,EAAAxC,MAAM,2BAGR,EAAKC,eAAeqC,KAEhBzB,GACF9E,QAAQ8E,OAAO4B,MAAM5B,GAGnB0B,GACFxG,QAAQwG,OAAOE,MAAMF,OAK7B,MAAOlC,GACP,IAAI5D,KAAK8D,WAKP,MAAMF,EAJN,EAAAmC,KAAK,2CACL/F,KAAKwD,eAAeI,GACpB,EAAAmC,KAAK,mD,OAMT,EAAA/C,QAAQ,mD,YAQF,YAAAiD,oBAAR,SACE9C,EACA+C,GAFF,gBACE,IAAA/C,MAAcnD,KAAK6E,mBACnB,IAAAqB,MAAA,IAEI/C,IAAQnD,KAAK6E,cACf,EAAA7B,QAAQ,6CAGV,IACE,EAAAmD,YAAYhD,GAAKc,SAAQ,SAAAmC,GAErBF,EADE,EAAAG,SAAS,EAAAC,KAAKnD,EAAKiD,IAAOG,cACpB,EAAKN,oBAAoB,EAAAK,KAAKnD,EAAKiD,GAAOF,GAE1CA,EAAMM,OAAO,EAAAF,KAAKnD,EAAKiD,OAGnC,MAAOxC,GAGP,MAFA,EAAAL,MAAM,oDACNvD,KAAKwD,eAAeI,GACdA,EAOR,OAJIT,IAAQnD,KAAK6E,cACf,EAAA7B,QAAQ,uDAGHkD,GAMD,YAAAO,kBAAR,WACE,GAAIzG,KAAK0G,YACP,OAAO1G,KAAK0G,YAGd,EAAA1D,QAAQ,2BAER,IAAM3E,EAAO2B,KAAK4C,UACZ+D,EAAkB,EAAAtH,QAAQhB,EAAM,gBAEtC,IACE2B,KAAK0G,YAAczE,KAAKvB,MACtB,EAAAwB,aAAayE,EAAiB,CAACvE,SAAU,UAE3C,MAAOwB,GAGP,MAFA,EAAAL,MAAM,qCAAoCoD,EAAe,OACzD3G,KAAKwD,eAAeI,GACdA,EAIR,OADA,EAAAZ,QAAQ,6CACDhD,KAAK0G,aAQN,YAAAE,oBAAR,SACExH,EACAoB,QAAA,IAAAA,MAAA,IAGE,MAIEA,EAAO,SAJTqG,OAAQ,IAAG,EAAAnF,EAAclC,IAAG,EAC5B,EAGEgB,EAAO,SAHTsG,OAAQ,IAAG,GAAK,EAChB,EAEEtG,EAAO,mBAFTuG,OAAkB,IAAG,GAAK,EAC1B,EACEvG,EAAO,iBADTwG,OAAgB,IAAG,GAAK,EAGpBC,EAAiBjH,KAAKyG,oBAEtBS,EACJF,IACED,GACAI,EAAGC,WAAWhI,IACd+H,EAAGE,UAAUjI,GAAMkI,SAqBvB,OAnBIT,IAAanF,EAAcnC,IAC7BH,EAAO,EAAAmI,SAASjI,QAAQC,MAAOH,GACtByH,IAAanF,EAAcrD,KACpCe,EAAO,EAAAmI,SAASvH,KAAK4C,UAAWxD,GACvByH,IAAanF,EAAclC,MACpCJ,EAAO,EAAAmI,SAASvH,KAAK6E,aAAczF,IAGhC0H,IACH1H,EAAU6H,EAAe3G,KAAI,IAAIlB,GAGnCA,EAAOA,EAAKoI,QAAQ,MAAO,KAEvBN,IAAgBH,IAElB3H,GADAA,EAAOA,EAAKoI,QAAQ,YAAa,KACrBA,QAAQ,QAAS,KAGxBpI,GAMD,YAAAqI,YAAR,sBACQC,EAA0B,GAE1BC,EAAmB3H,KAAKiG,sBAgB9B,OAdA,EAAAjD,QAAQ,uDACR2E,EAAiB1D,SAAQ,SAAAmC,GACvB,IAAMwB,EAAa,EAAKhB,oBAAoBR,GAE5C,IACEsB,EAAOE,GAAc,EAAA1F,aAAakE,EAAM,CAAChE,SAAU,SACnD,MAAOwB,GAGP,MAFA,EAAAL,MAAM,oCAAoC6C,EAAI,MAC9C,EAAK5C,eAAeI,GACdA,MAIV,EAAAZ,QAAQ,mDACD0E,GAGD,YAAAG,2BAAR,SACEC,EACAC,EACAH,GAEA,IAAMI,EAAUD,EAAKE,MAAMH,GAE3B,GAAIE,GAAWA,EAAQ,GAAGE,WAAW,KAAM,CACzC,IAAMC,EAAe,MAAMH,EAAQ,GAE/BI,EAAiB,EAAA/I,QAAQuI,EAAYO,GAEzCC,EAAiBpI,KAAK4G,oBAAoBwB,EAAgB,CACxDvB,SAAUnF,EAAcnC,IACxBuH,UAAU,EACVC,oBAAoB,IAGjB/G,KAAKqI,aAAaD,KACrBA,GAAkB,UAGpBL,EAAOA,EAAKP,QAAQM,EAAQ,KAAKM,EAAc,MAGjD,OAAOL,GAQD,YAAAO,qBAAR,SAA6B7D,EAAgBmD,GAA7C,WAKMW,GAFJ9D,GADAA,GADAA,EAASA,EAAO+C,QAAQ,QAAS,OACjBA,QAAQ,QAAS,OACjBA,QAAQ,MAAO,OAEZgB,MAAM,MAoBzB,OAlBAD,EAAQA,EAAME,KAAI,SAAAV,GAahB,OAZAA,EAAO,EAAKF,2BACV,4BACAE,EACAH,GAGK,EAAKC,2BACV,iCACAE,EACAH,OAMWtB,KAAK,OAQR,YAAA9B,eAAd,W,yGAEE,OADMkE,EAAU1I,KAAKyH,cACrB,GAAMzH,KAAKgE,gB,OAoBX,OApBA,SAEAhE,KAAK2I,YAAcvH,OAAOC,KAAKqH,GAE/B,EAAA1F,QAAQ,yCAEF4F,EAAwB,GAE9BxH,OAAOyH,QAAQH,GAASzE,SAAQ,SAAC,G,IAAC2D,EAAU,KAAEkB,EAAU,KACtDA,EAAaA,EAAWtB,QAAQ,YAAa,IAC7CsB,EAAa,EAAKR,qBAAqBQ,EAAYlB,GACnDgB,EAAYnF,KACV,mBAAmBmE,EAAU,QAASkB,EAAsBtB,QAC1D,OACA,QACD,UAIL,EAAAxE,QAAQ,wCACD,CAAP,EAAO4F,EAAYtC,KAAK,eAOlB,YAAA+B,aAAR,SAAqBT,GACnB,OAAO5H,KAAK2I,YAAYvI,SAASwH,IAO3B,YAAAlD,SAAR,SAAiBD,GACf,EAAAzB,QAAQ,gDAER,IAAMiE,EAAiBjH,KAAKyG,oBACtBtH,EAAQa,KAAK4E,WAEnB,IAAKzF,EAEH,MADA,EAAAoE,MAAM,+BACA,IAAIY,MAAM,+BAGlB,IAAM4E,EAAW/I,KAAK4G,oBAAoB,EAAAvH,QAAQW,KAAK4C,UAAWzD,GAAQ,CACxE0H,SAAUnF,EAAcrD,KACxB2I,kBAAkB,IAWpB,OARAvC,GACE,qBAAqBwC,EAAe3G,KAApC,iCAC4ByI,EAD5B,2BAKF,EAAA/F,QAAQ,6CAEDyB,GAOK,YAAAE,YAAd,SAA0BF,G,wGAClB3E,EAASE,KAAK6D,YACdxF,EAAO2B,KAAK4C,UACZwD,EAAO,EAAA/G,QAAQhB,EAAMyB,GACrBkJ,EAAa,EAAAC,QAAQ7C,GAE3B,EAAApD,QAAQ,yCACR,EAAAe,MAAM,4BAA4BiF,EAAU,Q,iBAG1C,O,sBAAA,GAAM9D,EAAM8D,I,cAAZ,S,aAIA,M,WAFA,EAAAzF,MAAM,qBAAqByF,EAAU,MACrChJ,KAAKwD,eAAe,GACd,E,OAGR,EAAAR,QAAQ,2BACR,EAAAA,QAAQ,wBAAwBlD,EAAM,YAEtC,IACE,EAAAoJ,cAAc9C,EAAM3B,EAAQ,CAACrC,SAAU,SACvC,MAAOwB,GAGP,MAFA,EAAAL,MAAM,oBAAoBzD,EAAM,KAChCE,KAAKwD,eAAeI,GACdA,E,OAGR,EAAAZ,QAAQ,wBAAwBlD,EAAM,U,YAE1C,EArnBA,CAA+B,EAAA2B,KAAlB,EAAA0H,YAioBb,SAAYzH,GAIV,cAKA,YAKA,YAdF,CAAYA,EAAA,EAAAA,gBAAA,EAAAA,cAAa,M,iICjpBzB,aACA,SASA0H,EAAQC,UAAU,CAChB9F,MAAO,MACPwC,KAAM,SACNnG,KAAM,OACNmE,MAAO,UAGT,IAKYpE,EALR2J,GAAa,GAKL3J,EAAA,EAAAA,YAAA,EAAAA,UAAS,KAInB,cAKA,cAKA,cAKA,oBAKA,gBAOW,EAAA4D,MAAQ,SAACgG,GACpB,OAAID,EACK,QAAaC,GAEb,MAQE,EAAAxD,KAAO,SAACwD,GACnB,OAAID,EACK,OAAYC,GAEZ,MAQE,EAAA3J,KAAO,SAAC2J,GACnB,OAAID,EACK,OAAYC,GAEZ,MAQE,EAAAvG,QAAU,SAACuG,GACtB,OAAID,EACK,UAAeC,GAEf,MAQE,EAAAxF,MAAQ,SAACwF,GACpB,OAAID,EACK,QAAaC,GAEb,MAQE,EAAAzH,KAAO,SAAC0H,EAAeC,GAClCL,EAAQM,UAAU,CAChBD,MAAK,EACLE,OAAQP,EAAQO,OAAOC,QACrBR,EAAQO,OAAOE,WACfT,EAAQO,OAAOH,MAAM,CAACA,MAAK,IAC3BJ,EAAQO,OAAOG,YACfV,EAAQO,OAAOI,cACfX,EAAQO,OAAOK,QACb,SAACC,GAAe,UAAIA,EAAMT,MAAK,MAAMS,EAAMR,MAAK,OAAOQ,EAAMV,YAGjEW,WAAY,CAAC,IAAId,EAAQc,WAAWC,WAGtCb,GAAa,I,qBChIf9K,EAAOD,QAAU6L,QAAQ,S,qBCAzB5L,EAAOD,QAAU6L,QAAQ,O,qBCAzB5L,EAAOD,QAAU6L,QAAQ,W,qBCAzB5L,EAAOD,QAAU6L,QAAQ,Y,qBCAzB5L,EAAOD,QAAU6L,QAAQ,S,qBCAzB5L,EAAOD,QAAU6L,QAAQ,W,qBCAzB5L,EAAOD,QAAU6L,QAAQ,Q,qBCAzB5L,EAAOD,QAAU6L,QAAQ,aCCrBC,EAA2B,GAG/B,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqB/I,IAAjBgJ,EACH,OAAOA,EAAajM,QAGrB,IAAIC,EAAS6L,EAAyBE,GAAY,CAGjDhM,QAAS,IAOV,OAHAkM,EAAoBF,GAAUG,KAAKlM,EAAOD,QAASC,EAAQA,EAAOD,QAAS+L,GAGpE9L,EAAOD,Q,iGCrBf,aAAQ,2EAAA4K,c","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(global, function() {\nreturn ","import * as args from 'args'\nimport * as path from 'path'\nimport {ELogLevel} from './log'\n\n/**\n * CLI argument names\n */\nexport enum ECliArgument {\n  /**\n   * Main file of non-bundled package source\n   */\n  entry = 'entry',\n\n  /**\n   * Root directory of targeted package\n   */\n  root = 'root',\n\n  /**\n   * Temporary directory required during generation\n   */\n  tmp = 'tmp',\n\n  /**\n   * Additional TSC properties\n   */\n  tsc = 'tsc',\n\n  /**\n   * Selected logging level\n   */\n  logLevel = 'logLevel',\n\n  /**\n   * Output file path (relative to root)\n   */\n  output = 'output',\n\n  /**\n   * Flag which forces using own TSC as opposed to target TSC\n   * This should only be used for testing npm-dts itself\n   * This is because it generates incorrect module names\n   */\n  testMode = 'testMode',\n\n  /**\n   * Flag which forces attempting generation at least partially despite errors\n   */\n  force = 'force',\n}\n\n/**\n * Format for storing passed argument values\n */\nexport interface INpmDtsArgs {\n  /**\n   * Iterator\n   */\n  [argName: string]: string | boolean\n\n  /**\n   * Main file of non-bundled package source\n   */\n  entry?: string\n\n  /**\n   * Root directory of targeted package\n   */\n  root?: string\n\n  /**\n   * Temporary directory required during generation\n   */\n  tmp?: string\n\n  /**\n   * Additional TSC properties\n   */\n  tsc?: string\n\n  /**\n   * Selected logging level\n   */\n  logLevel?: ELogLevel\n\n  /**\n   * Attempts to at least partially generate typings ignoring non-critical errors\n   */\n  force?: boolean\n\n  /**\n   * Output file path (relative to root)\n   */\n  output?: string\n\n  /**\n   * Flag which forces using own TSC as opposed to target TSC\n   * This should only be used for testing npm-dts itself\n   * This is because it generates incorrect module names\n   */\n  testMode?: boolean\n}\n\n/**\n * CLI usage logic\n */\nexport class Cli {\n  /**\n   * Stores whether module was successfully launched\n   */\n  protected launched = false\n\n  /**\n   * Stores whether TMP directory location was passed\n   */\n  protected tmpPassed = false\n\n  /**\n   * Stores current CLI argument values\n   */\n  private args: INpmDtsArgs = {\n    entry: 'index.ts',\n    root: path.resolve(process.cwd()),\n    tmp: '<TEMP>',\n    tsc: '',\n    logLevel: ELogLevel.info,\n    force: false,\n    output: 'index.d.ts',\n    testMode: false,\n  }\n\n  /**\n   * Automatically reads CLI arguments and performs actions based on them\n   */\n  public constructor(injectedArguments?: INpmDtsArgs) {\n    if (injectedArguments) {\n      this.launched = true\n      this.storeArguments(injectedArguments)\n    } else {\n      args\n        .option(\n          ['e', 'entry'],\n          'Entry/main package file before bundling, relative to project root',\n        )\n        .option(\n          ['r', 'root'],\n          'NPM package directory containing package.json',\n          this.args.root,\n        )\n        .option(\n          ['t', 'tmp'],\n          'Directory for storing temporary information',\n          this.args.tmp,\n          (value: string) => {\n            if (!value.includes('<')) {\n              this.tmpPassed = true\n            }\n\n            return value\n          },\n        )\n        .option(\n          ['c', 'tsc'],\n          'Passed through non-validated additional TSC options',\n          this.args.tsc,\n        )\n        .option(\n          ['L', 'logLevel'],\n          'Log level (error, warn, info, verbose, debug)',\n          this.args.logLevel,\n        )\n        .option(\n          ['f', 'force'],\n          'Ignores non-critical errors and attempts to at least partially generate typings',\n          this.args.force,\n        )\n        .option(\n          ['o', 'output'],\n          'Overrides recommended output target to a custom one',\n          this.args.output,\n        )\n        .option(\n          ['m', 'testMode'],\n          'Configures npm-dts for self-test',\n          this.args.testMode,\n        )\n        .command('generate', 'Start generation', (name, sub, options) => {\n          this.launched = true\n          this.storeArguments(options)\n        })\n        .example(\n          'npm-dts generate',\n          'Generates index.d.ts file and updates package.json for CWD.',\n        )\n        .example(\n          'npm-dts -r /your/project/path generate',\n          'Performs generation on a custom path.',\n        )\n\n      args.parse(process.argv, {\n        name: 'npm-dts',\n        mri: {},\n        mainColor: 'yellow',\n        subColor: 'dim',\n      })\n\n      if (!this.launched) {\n        args.showHelp()\n      }\n    }\n  }\n\n  /**\n   * Gathers current value of a particular CLI argument\n   * @param arg argument name\n   */\n  protected getArgument(arg: ECliArgument) {\n    return this.args[arg]\n  }\n\n  /**\n   * Dynamically overrides value of stored argument\n   * @param arg argument name\n   * @param value argument value\n   */\n  protected setArgument(arg: ECliArgument, value: string | boolean) {\n    // @ts-ignore\n    this.args[arg] = value\n  }\n\n  /**\n   * Stores entered CLI arguments\n   * @param passedArguments arguments entered to CLI\n   */\n  private storeArguments(passedArguments: any = this.args) {\n    for (const argName of Object.keys(this.args)) {\n      this.args[argName] = Object.is(passedArguments[argName], undefined)\n        ? this.args[argName]\n        : passedArguments[argName]\n    }\n  }\n}\n","import {readdirSync, statSync, writeFileSync} from 'fs'\nimport {readFileSync} from 'fs'\nimport * as mkdir from 'mkdirp'\nimport * as npmRun from 'npm-run'\nimport {join, relative, resolve, dirname} from 'path'\nimport * as rm from 'rimraf'\nimport * as tmp from 'tmp'\nimport {Cli, ECliArgument, INpmDtsArgs} from './cli'\nimport {debug, ELogLevel, error, info, init, verbose, warn} from './log'\nimport * as fs from 'fs'\n\nconst MKDIR_RETRIES = 5\n\n/**\n * Logic for generating aggregated typings for NPM module\n */\nexport class Generator extends Cli {\n  private packageInfo: any\n  private moduleNames: string[]\n  private throwErrors: boolean\n  private cacheContentEmptied: boolean = true\n\n  /**\n   * Auto-launches generation based on command line arguments\n   * @param injectedArguments generation arguments (same as CLI)\n   * @param enableLog enables logging when true, null allows application to decide\n   * @param throwErrors makes generation throw errors when true\n   */\n  public constructor(\n    injectedArguments?: INpmDtsArgs,\n    enableLog: boolean | null = null,\n    throwErrors = false,\n  ) {\n    super(injectedArguments)\n\n    this.throwErrors = throwErrors\n\n    if (enableLog === null) {\n      enableLog = !injectedArguments\n    }\n\n    if (enableLog) {\n      init('npm-dts', this.getLogLevel())\n\n      const myPackageJson = JSON.parse(\n        readFileSync(resolve(__dirname, '..', 'package.json'), {\n          encoding: 'utf8',\n        }),\n      )\n\n      const soft = `          npm-dts v${myPackageJson.version}                `\n      let author = '          by Vytenis UrbonaviÄius                          '\n      let spaces = '                                                           '\n      let border = '___________________________________________________________'\n\n      author = author.substring(0, soft.length)\n      spaces = spaces.substring(0, soft.length)\n      border = border.substring(0, soft.length)\n\n      info(` ${border} `)\n      info(`|${spaces}|`)\n      info(`|${spaces}|`)\n      info(`|${soft}|`)\n      info(`|${author}|`)\n      info(`|${spaces}|`)\n      info(`|${border}|`)\n      info(` ${spaces} `)\n    }\n  }\n\n  /**\n   * Executes generation of single declaration file\n   */\n  public async generate() {\n    info(`Generating declarations for \"${this.getRoot()}\"...`)\n\n    let hasError = false\n    let exception = null\n    const cleanupTasks: (() => void)[] = []\n\n    if (!this.tmpPassed) {\n      verbose('Locating OS Temporary Directory...')\n\n      try {\n        await new Promise<void>(done => {\n          tmp.dir((tmpErr, tmpDir, rmTmp) => {\n            if (tmpErr) {\n              error('Could not create OS Temporary Directory!')\n              this.showDebugError(tmpErr)\n              throw tmpErr\n            }\n\n            verbose('OS Temporary Directory was located!')\n            this.setArgument(ECliArgument.tmp, resolve(tmpDir, 'npm-dts'))\n\n            cleanupTasks.push(() => {\n              verbose('Deleting OS Temporary Directory...')\n              rmTmp()\n              verbose('OS Temporary Directory was deleted!')\n            })\n            done()\n          })\n        })\n      } catch (e) {\n        hasError = true\n        exception = e\n      }\n    }\n\n    if (!hasError) {\n      await this._generate().catch(async e => {\n        hasError = true\n\n        const output = this.getOutput()\n\n        error(`Generation of ${output} has failed!`)\n        this.showDebugError(e)\n\n        if (!this.useForce()) {\n          if (this.getLogLevel() === ELogLevel.debug) {\n            info(\n              'If issue is not severe, you can try forcing execution using force flag.',\n            )\n            info(\n              'In case of command line usage, add \"-f\" as the first parameter.',\n            )\n          } else {\n            info('You should try running npm-dts with debug level logging.')\n            info(\n              'In case of command line, debug mode is enabled using \"-L debug\".',\n            )\n          }\n        }\n\n        if (!this.cacheContentEmptied) {\n          await this.clearTempDir()\n        }\n\n        exception = e\n      })\n    }\n\n    cleanupTasks.forEach(task => task())\n\n    if (!hasError) {\n      info('Generation is completed!')\n    } else {\n      error('Generation failed!')\n\n      if (this.throwErrors) {\n        throw exception || new Error('Generation failed!')\n      }\n    }\n  }\n\n  /**\n   * Logs serialized error if it exists\n   * @param e - error to be shown\n   */\n  private showDebugError(e: any) {\n    if (e) {\n      if (e.stdout) {\n        debug(`Error: \\n${e.stdout.toString()}`)\n      } else {\n        debug(`Error: \\n${JSON.stringify(e)}`)\n      }\n    }\n  }\n\n  /**\n   * Launches generation of typings\n   */\n  private async _generate() {\n    await this.generateTypings()\n    let source = await this.combineTypings()\n    source = this.addAlias(source)\n    await this.storeResult(source)\n  }\n\n  private getLogLevel(): ELogLevel {\n    const logLevel = this.getArgument(ECliArgument.logLevel) as ELogLevel\n    return ELogLevel[logLevel] ? logLevel : ELogLevel.info\n  }\n\n  /**\n   * Gathers entry file address (relative to project root path)\n   */\n  private getEntry(): string {\n    return this.getArgument(ECliArgument.entry) as string\n  }\n\n  /**\n   * Gathers target project root path\n   */\n  private getRoot(): string {\n    return resolve(this.getArgument(ECliArgument.root) as string)\n  }\n\n  /**\n   * Gathers TMP directory to be used for TSC operations\n   */\n  private getTempDir(): string {\n    return resolve(this.getArgument(ECliArgument.tmp) as string)\n  }\n\n  /**\n   * Gathers output path to be used (relative to root)\n   */\n  private getOutput(): string {\n    return this.getArgument(ECliArgument.output) as string\n  }\n\n  /**\n   * Checks if script is forced to use its built-in TSC\n   */\n  private useTestMode(): boolean {\n    return this.getArgument(ECliArgument.testMode) as boolean\n  }\n\n  /**\n   * Checks if script is forced to attempt generation despite errors\n   */\n  private useForce(): boolean {\n    return this.getArgument(ECliArgument.force) as boolean\n  }\n\n  /**\n   * Creates TMP directory to be used for TSC operations\n   * @param retries amount of times to retry on failure\n   */\n  private makeTempDir(retries = MKDIR_RETRIES): Promise<void> {\n    const tmpDir = this.getTempDir()\n    verbose('Preparing \"tmp\" directory...')\n\n    return new Promise((done, fail) => {\n      mkdir(tmpDir)\n        .then(() => {\n          this.cacheContentEmptied = false\n          verbose('\"tmp\" directory was prepared!')\n          done()\n        })\n        .catch(mkdirError => {\n          error(`Failed to create \"${tmpDir}\"!`)\n          this.showDebugError(mkdirError)\n\n          if (retries) {\n            const sleepTime = 100\n            verbose(`Will retry in ${sleepTime}ms...`)\n\n            setTimeout(() => {\n              this.makeTempDir(retries - 1).then(done, fail)\n            }, sleepTime)\n          } else {\n            error(`Stopped trying after ${MKDIR_RETRIES} retries!`)\n            fail()\n          }\n        })\n    })\n  }\n\n  /**\n   * Removes TMP directory\n   */\n  private clearTempDir() {\n    const tmpDir = this.getTempDir()\n    verbose('Cleaning up \"tmp\" directory...')\n\n    return new Promise<void>((done, fail) => {\n      rm(tmpDir, rmError => {\n        if (rmError) {\n          error(`Could not clean up \"tmp\" directory at \"${tmpDir}\"!`)\n          this.showDebugError(rmError)\n          fail()\n        } else {\n          this.cacheContentEmptied = true\n          verbose('\"tmp\" directory was cleaned!')\n          done()\n        }\n      })\n    })\n  }\n\n  /**\n   * Re-creates empty TMP directory to be used for TSC operations\n   */\n  private resetCacheDir() {\n    verbose('Will now reset \"tmp\" directory...')\n    return new Promise((done, fail) => {\n      this.clearTempDir().then(() => {\n        this.makeTempDir().then(done, fail)\n      }, fail)\n    })\n  }\n\n  /**\n   * Generates per-file typings using TSC\n   */\n  private async generateTypings() {\n    await this.resetCacheDir()\n\n    verbose('Generating per-file typings using TSC...')\n\n    const tscOptions = this.getArgument(ECliArgument.tsc) as string\n\n    const cmd =\n      'tsc --declaration --emitDeclarationOnly --declarationDir \"' +\n      this.getTempDir() +\n      '\"' +\n      (tscOptions.length ? ` ${tscOptions}` : '')\n\n    debug(cmd)\n\n    try {\n      npmRun.execSync(\n        cmd,\n        {\n          cwd: this.useTestMode() ? resolve(__dirname, '..') : this.getRoot(),\n        },\n        (err: any, stdout: any, stderr: any) => {\n          if (err) {\n            if (this.useForce()) {\n              warn('TSC exited with errors!')\n            } else {\n              error('TSC exited with errors!')\n            }\n\n            this.showDebugError(err)\n          } else {\n            if (stdout) {\n              process.stdout.write(stdout)\n            }\n\n            if (stderr) {\n              process.stderr.write(stderr)\n            }\n          }\n        },\n      )\n    } catch (e) {\n      if (this.useForce()) {\n        warn('Suppressing errors due to \"force\" flag!')\n        this.showDebugError(e)\n        warn('Generated declaration files might not be valid!')\n      } else {\n        throw e\n      }\n    }\n\n    verbose('Per-file typings have been generated using TSC!')\n  }\n\n  /**\n   * Gathers a list of created per-file declaration files\n   * @param dir directory to be scanned for files (called during recursion)\n   * @param files discovered array of files (called during recursion)\n   */\n  private getDeclarationFiles(\n    dir: string = this.getTempDir(),\n    files: string[] = [],\n  ) {\n    if (dir === this.getTempDir()) {\n      verbose('Loading list of generated typing files...')\n    }\n\n    try {\n      readdirSync(dir).forEach(file => {\n        if (statSync(join(dir, file)).isDirectory()) {\n          files = this.getDeclarationFiles(join(dir, file), files)\n        } else {\n          files = files.concat(join(dir, file))\n        }\n      })\n    } catch (e) {\n      error('Failed to load list of generated typing files...')\n      this.showDebugError(e)\n      throw e\n    }\n\n    if (dir === this.getTempDir()) {\n      verbose('Successfully loaded list of generated typing files!')\n    }\n\n    return files\n  }\n\n  /**\n   * Loads package.json information of target project\n   */\n  private getPackageDetails() {\n    if (this.packageInfo) {\n      return this.packageInfo\n    }\n\n    verbose('Loading package.json...')\n\n    const root = this.getRoot()\n    const packageJsonPath = resolve(root, 'package.json')\n\n    try {\n      this.packageInfo = JSON.parse(\n        readFileSync(packageJsonPath, {encoding: 'utf8'}),\n      )\n    } catch (e) {\n      error(`Failed to read package.json at \"'${packageJsonPath}'\"`)\n      this.showDebugError(e)\n      throw e\n    }\n\n    verbose('package.json information has been loaded!')\n    return this.packageInfo\n  }\n\n  /**\n   * Generates module name based on file path\n   * @param path path to be converted to module name\n   * @param options additional conversion options\n   */\n  private convertPathToModule(\n    path: string,\n    options: ConvertPathToModuleOptions = {},\n  ) {\n    const {\n      rootType = IBasePathType.tmp,\n      noPrefix = false,\n      noExtensionRemoval = false,\n      noExistenceCheck = false,\n    } = options\n\n    const packageDetails = this.getPackageDetails()\n\n    const fileExisted =\n      noExistenceCheck ||\n      (!noExtensionRemoval &&\n        fs.existsSync(path) &&\n        fs.lstatSync(path).isFile())\n\n    if (rootType === IBasePathType.cwd) {\n      path = relative(process.cwd(), path)\n    } else if (rootType === IBasePathType.root) {\n      path = relative(this.getRoot(), path)\n    } else if (rootType === IBasePathType.tmp) {\n      path = relative(this.getTempDir(), path)\n    }\n\n    if (!noPrefix) {\n      path = `${packageDetails.name}/${path}`\n    }\n\n    path = path.replace(/\\\\/g, '/')\n\n    if (fileExisted && !noExtensionRemoval) {\n      path = path.replace(/\\.[^.]+$/g, '')\n      path = path.replace(/\\.d$/g, '')\n    }\n\n    return path\n  }\n\n  /**\n   * Loads generated per-file declaration files\n   */\n  private loadTypings() {\n    const result: IDeclarationMap = {}\n\n    const declarationFiles = this.getDeclarationFiles()\n\n    verbose('Loading declaration files and mapping to modules...')\n    declarationFiles.forEach(file => {\n      const moduleName = this.convertPathToModule(file)\n\n      try {\n        result[moduleName] = readFileSync(file, {encoding: 'utf8'})\n      } catch (e) {\n        error(`Could not load declaration file '${file}'!`)\n        this.showDebugError(e)\n        throw e\n      }\n    })\n\n    verbose('Loaded declaration files and mapped to modules!')\n    return result\n  }\n\n  private resolveImportSourcesAtLine(\n    regexp: RegExp,\n    line: string,\n    moduleName: string,\n  ) {\n    const matches = line.match(regexp)\n\n    if (matches && matches[2].startsWith('.')) {\n      const relativePath = `../${matches[2]}`\n\n      let resolvedModule = resolve(moduleName, relativePath)\n\n      resolvedModule = this.convertPathToModule(resolvedModule, {\n        rootType: IBasePathType.cwd,\n        noPrefix: true,\n        noExtensionRemoval: true,\n      })\n\n      if (!this.moduleExists(resolvedModule)) {\n        resolvedModule += '/index'\n      }\n\n      line = line.replace(regexp, `$1${resolvedModule}$3`)\n    }\n\n    return line\n  }\n\n  /**\n   * Alters import sources to avoid relative addresses and default index usage\n   * @param source import source to be resolved\n   * @param moduleName name of module containing import\n   */\n  private resolveImportSources(source: string, moduleName: string) {\n    source = source.replace(/\\r\\n/g, '\\n')\n    source = source.replace(/\\n\\r/g, '\\n')\n    source = source.replace(/\\r/g, '\\n')\n\n    let lines = source.split('\\n')\n\n    lines = lines.map(line => {\n      line = this.resolveImportSourcesAtLine(\n        /(from ['\"])([^'\"]+)(['\"])/,\n        line,\n        moduleName,\n      )\n\n      line = this.resolveImportSourcesAtLine(\n        /(import\\(['\"])([^'\"]+)(['\"]\\))/,\n        line,\n        moduleName,\n      )\n\n      return line\n    })\n\n    source = lines.join('\\n')\n\n    return source\n  }\n\n  /**\n   * Combines typings into a single declaration source\n   */\n  private async combineTypings() {\n    const typings = this.loadTypings()\n    await this.clearTempDir()\n\n    this.moduleNames = Object.keys(typings)\n\n    verbose('Combining typings into single file...')\n\n    const sourceParts: string[] = []\n\n    Object.entries(typings).forEach(([moduleName, fileSource]) => {\n      fileSource = fileSource.replace(/declare /g, '')\n      fileSource = this.resolveImportSources(fileSource, moduleName)\n      sourceParts.push(\n        `declare module '${moduleName}' {\\n${(fileSource as string).replace(\n          /^./gm,\n          '  $&',\n        )}\\n}`,\n      )\n    })\n\n    verbose('Combined typings into a single file!')\n    return sourceParts.join('\\n')\n  }\n\n  /**\n   * Verifies if module specified exists among known modules\n   * @param moduleName name of module to be checked\n   */\n  private moduleExists(moduleName: string) {\n    return this.moduleNames.includes(moduleName)\n  }\n\n  /**\n   * Adds alias for main NPM package file to generated .d.ts source\n   * @param source generated .d.ts declaration source so far\n   */\n  private addAlias(source: string) {\n    verbose('Adding alias for main file of the package...')\n\n    const packageDetails = this.getPackageDetails()\n    const entry = this.getEntry()\n\n    if (!entry) {\n      error('No entry file is available!')\n      throw new Error('No entry file is available!')\n    }\n\n    const mainFile = this.convertPathToModule(resolve(this.getRoot(), entry), {\n      rootType: IBasePathType.root,\n      noExistenceCheck: true,\n    })\n\n    source +=\n      `\\ndeclare module '${packageDetails.name}' {\\n` +\n      `  import main = require('${mainFile}');\\n` +\n      '  export = main;\\n' +\n      '}'\n\n    verbose('Successfully created alias for main file!')\n\n    return source\n  }\n\n  /**\n   * Stores generated .d.ts declaration source into file\n   * @param source generated .d.ts source\n   */\n  private async storeResult(source: string) {\n    const output = this.getOutput()\n    const root = this.getRoot()\n    const file = resolve(root, output)\n    const folderPath = dirname(file)\n\n    verbose('Ensuring that output folder exists...')\n    debug(`Creating output folder: \"${folderPath}\"...`)\n\n    try {\n      await mkdir(folderPath)\n    } catch (mkdirError) {\n      error(`Failed to create \"${folderPath}\"!`)\n      this.showDebugError(mkdirError)\n      throw mkdirError\n    }\n\n    verbose('Output folder is ready!')\n    verbose(`Storing typings into ${output} file...`)\n\n    try {\n      writeFileSync(file, source, {encoding: 'utf8'})\n    } catch (e) {\n      error(`Failed to create ${output}!`)\n      this.showDebugError(e)\n      throw e\n    }\n\n    verbose(`Successfully created ${output} file!`)\n  }\n}\n\n/**\n * Map of modules and their declarations\n */\nexport interface IDeclarationMap {\n  [moduleNames: string]: string\n}\n\n/**\n * Types of base path used during path resolving\n */\nexport enum IBasePathType {\n  /**\n   * Base path is root of targeted project\n   */\n  root = 'root',\n\n  /**\n   * Base path is tmp directory\n   */\n  tmp = 'tmp',\n\n  /**\n   * Base path is CWD\n   */\n  cwd = 'cwd',\n}\n\n/**\n * Additional conversion options\n */\nexport interface ConvertPathToModuleOptions {\n  /**\n   * Type of base path used during path resolving\n   */\n  rootType?: IBasePathType\n\n  /**\n   * Disables addition of module name as prefix for module name\n   */\n  noPrefix?: boolean\n\n  /**\n   * Disables extension removal\n   */\n  noExtensionRemoval?: boolean\n\n  /**\n   * Disables existence check and assumes that file exists\n   */\n  noExistenceCheck?: boolean\n}\n","import * as winston from 'winston'\nimport {\n  debug as winstonDebug,\n  error as winstonError,\n  info as winstonInfo,\n  silly as winstonSilly,\n  verbose as winstonVerbose,\n  warn as winstonWarn,\n} from 'winston'\n\nwinston.addColors({\n  error: 'red',\n  warn: 'yellow',\n  info: 'cyan',\n  debug: 'green',\n})\n\nlet logEnabled = false\n\n/**\n * Supported debug levels\n */\nexport enum ELogLevel {\n  /**\n   * Error\n   */\n  error = 'error',\n\n  /**\n   * Warning\n   */\n  warn = 'warn',\n\n  /**\n   * Information\n   */\n  info = 'info',\n\n  /**\n   * Verbose information\n   */\n  verbose = 'verbose',\n\n  /**\n   * Debug information\n   */\n  debug = 'debug',\n}\n\n/**\n * Logs error message\n * @param message Message to be logged\n */\nexport const error = (message: string) => {\n  if (logEnabled) {\n    return winstonError(message)\n  } else {\n    return null\n  }\n}\n\n/**\n * Logs warning message\n * @param message Message to be logged\n */\nexport const warn = (message: string) => {\n  if (logEnabled) {\n    return winstonWarn(message)\n  } else {\n    return null\n  }\n}\n\n/**\n * Logs informational message\n * @param message Message to be logged\n */\nexport const info = (message: string) => {\n  if (logEnabled) {\n    return winstonInfo(message)\n  } else {\n    return null\n  }\n}\n\n/**\n * Logs verbose message\n * @param message Message to be logged\n */\nexport const verbose = (message: string) => {\n  if (logEnabled) {\n    return winstonVerbose(message)\n  } else {\n    return null\n  }\n}\n\n/**\n * Logs debug message\n * @param message Message to be logged\n */\nexport const debug = (message: string) => {\n  if (logEnabled) {\n    return winstonDebug(message)\n  } else {\n    return null\n  }\n}\n\n/**\n * Initializes and enables logging\n * @param label prefix to be used before each log line\n */\nexport const init = (label: string, level: ELogLevel) => {\n  winston.configure({\n    level,\n    format: winston.format.combine(\n      winston.format.colorize(),\n      winston.format.label({label}),\n      winston.format.timestamp(),\n      winston.format.prettyPrint(),\n      winston.format.printf(\n        (parts: any) => `[${parts.label}] [${parts.level}] : ${parts.message}`,\n      ),\n    ),\n    transports: [new winston.transports.Console()],\n  })\n\n  logEnabled = true\n}\n","module.exports = require(\"args\");","module.exports = require(\"fs\");","module.exports = require(\"mkdirp\");","module.exports = require(\"npm-run\");","module.exports = require(\"path\");","module.exports = require(\"rimraf\");","module.exports = require(\"tmp\");","module.exports = require(\"winston\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","export {Generator} from './lib/generator'\n"],"sourceRoot":""}